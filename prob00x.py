from euler_utils import isPalindrome, fib
from operator import mul

"""
Problem 1 Statement:
	If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. 
	The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.
"""
def doProb1():
	threes = []
	fives = []
	# all multiples of 3 between 1 and 1000
	for k in range(1,int(1000.0/3)+1):
		threes.append(k*3)
	# all multiples of 5 between 1 and 1000
	for k in range(1,int(1000/5)):
		fives.append(k*5)
	
	# merge the two lists of multiples and remove duplicates
	tot = list(set(fives + threes))
	print sum(tot)

"""
Problem 2 Statement:

Solution:
	Using Binet's formula to compute all even-valued Fibonacci numbers until you exceed
	4 million and sum the result
"""
def doProb2():
	lim = 4e6
	
	nums = []
	n = 1
	while True:
		num =  fib(n)
		if (num <= lim):
			if num % 2 == 0:
				nums.append(num)
		else:
			break;
		n += 1
	
	print sum(nums)

"""
Problem 4 Statement:

A palindromic number reads the same both ways. The largest palindrome made from the product of 
two 2-digit numbers is 9009 = 91 x 99. Find the largest palindrome made from the product of two 3 digit numbers.

	Solves problem 4  using brute force, taking O(N^2) time. Finds all palindromes, then
	takes the biggest.
	
	Optimization: loop BACKWARD over three-digit numbers because you'll hit that palindrome earlier
"""
def doProb4():
	biggest = 0
	for x in range(999,99,-1):
		for y in range(999,99,-1):
			if isPalindrome(x*y):
				if biggest < x*y:
					biggest = x*y
	print "Biggest palindrome is",biggest

"""
Problem 8 Statement:
	Find the greatest product of five consecutive digits in the 1000-digit number.

	73167176531330624919225119674426574742355349194934
	96983520312774506326239578318016984801869478851843
	85861560789112949495459501737958331952853208805511
	12540698747158523863050715693290963295227443043557
	66896648950445244523161731856403098711121722383113
	62229893423380308135336276614282806444486645238749
	30358907296290491560440772390713810515859307960866
	70172427121883998797908792274921901699720888093776
	65727333001053367881220235421809751254540594752243
	52584907711670556013604839586446706324415722155397
	53697817977846174064955149290862569321978468622482
	83972241375657056057490261407972968652414535100474
	82166370484403199890008895243450658541227588666881
	16427171479924442928230863465674813919123162824586
	17866458359124566529476545682848912883142607690042
	24219022671055626321111109370544217506941658960408
	07198403850962455444362981230987879927244284909188
	84580156166097919133875499200524063689912560717606
	05886116467109405077541002256983155200055935729725
	71636269561882670428252483600823257530420752963450

"""
def doProb8():
	num = "73167176531330624919225119674426574742355349194934\
96983520312774506326239578318016984801869478851843\
85861560789112949495459501737958331952853208805511\
12540698747158523863050715693290963295227443043557\
66896648950445244523161731856403098711121722383113\
62229893423380308135336276614282806444486645238749\
30358907296290491560440772390713810515859307960866\
70172427121883998797908792274921901699720888093776\
65727333001053367881220235421809751254540594752243\
52584907711670556013604839586446706324415722155397\
53697817977846174064955149290862569321978468622482\
83972241375657056057490261407972968652414535100474\
82166370484403199890008895243450658541227588666881\
16427171479924442928230863465674813919123162824586\
17866458359124566529476545682848912883142607690042\
24219022671055626321111109370544217506941658960408\
07198403850962455444362981230987879927244284909188\
84580156166097919133875499200524063689912560717606\
05886116467109405077541002256983155200055935729725\
71636269561882670428252483600823257530420752963450"

	# search
	largest = 0
	for k in range(0,len(num)-5):
		sub = list(num[k:(k+5)])
		nums = [int(n) for n in sub]
		p = reduce(lambda x, y: x * y, nums, 1)
		if p > largest:
			largest = p
	print largest